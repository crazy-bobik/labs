/*
Написано в Kate
Скомпільовано через g++
Розв'язок системи диренціальних рівнянь методом
Рунге-Кутта-Мерсона з автоматичним вибором кроку
*/


/*________________________________________________________________________________________________________
\ Для себе:
\ sys: приймає поточний x, вектор y і його довжину n; повертає вектор значень довжини n;
\ k1:  приймає поточний x, вектор y і його довжину n, вказівник на систему;
\ ...
\ k5:...
\ accuracy: приймає вектори k1, k3, k4, k5 та їх довжину n; повертає вектор похибки довжиною n;
\ ypp: приймає вектори y, k1, k4, k5 та їх довжину n; повертає вектор y(n+1);
________________________________________________________________________________________________________*/

const double t = 1.0/3.0;

//--------------------------------------------------------------------------------------------------------
//рівняння виду u'=f(x;y)

double sys(double x, double *y, double *u, int size)
{
	u[1] = (-2*y[1]);
	u[2] = (x-y[2]);
}

//--------------------------------------------------------------------------------------------------------
//k1
void k1( double x, double *y, double *q1, double h, int size, double(*f)(double, double*, double*, int) )
{
	int i;
	double a[size];
	sys(x, y, a, size);
	for(i=0;i<=size;i++)
	{
		q[i] = (t)*h*a[i]);
	}
}

//--------------------------------------------------------------------------------------------------------
//k2
void k2( double x, double *y, double *q2, double h, int size, double(*f)(double, double*, double*, int), double *q1 )
{
	int i;
	double a[size];
	//sys( (x + t*h[
	for(i=0;i<=size;i++)
	{
    		q2[i] = (t)*h*f((x + t*h),(y[i] + q1[i]));
	}
}

//--------------------------------------------------------------------------------------------------------
//k3
void k3( double x, double *y, double *q3, double h, int size, double(*f)(double, double*, double*, int), double *q1, double *q2 )
{
	int i;
	for(i=0;i<=size;i++)
	{
		q3[i] = (t)*h*f((x + t*h),(y[i] + 0.5*q1[i] + 0.5*q2[i]));
	}
}

//--------------------------------------------------------------------------------------------------------
//k4
void k4( double x, double *y, double *q4, double h, int size, double(*f)(double, double*, double*, int), double *q1, double *q3 )
{	int i;
	for(i=0;i<=size;i++)
	{
		q4[i] = (t)*h*f((x + 0.5*h),(y[i] + 0.375*q1[i] + 2.125*q3[i]));
	}
}

//--------------------------------------------------------------------------------------------------------
//k5
void k5( double x, double *y, double *q5, double h, int size, double(*f)(double, double*, double*, int), double *q1, double *q3, double *q4 )
{
	int i;
	for(i=0;i<=size;i++)
	{
		q5[i] = (t)*h*f((x + h),(y[i] + 1.5*q1[i] - 4.5*q3[i] + 6*q4[i]));
}

//--------------------------------------------------------------------------------------------------------
//похибка на кроці
void accuracy( double *d, double *q1, double *q3, double *q4, double *q5, int size )
{
	
	int i;
	for(i=0;i<=size;i++)
	{
		d[i] = (q1[i] - 4.5*q3[i] + 4*q4[i] - 0.5*q5[i]);
	}
}

//--------------------------------------------------------------------------------------------------------
//Y(n+1)
void ypp( double *yn, double *y, double *q1, double *q4, double *q5 )
{
	int i;
	for(i=0;i<=size;i++)
	{
		yn[i] = (y[i] + 0.5*(q1[i] + 4*q4[i] + q5[i]));
}

//--------------------------------------------------------------------------------------------------------
//функція корекції кроку
double corect(double e, double d, double h)
{
    	if( fabs(d)>e )
    	{
        	return(0.5*h);
    	}
    	else
    	{
        	if( fabs(d)<(0.03125*e) )
            	{
                   	return(2*h);
            	}
        	else
        	{
                	if( fabs(d)<=e) && ( fabs(d)>=(0.03125*e)) )
                	{
				return(h);
                	}
        	}	
    	};

}
